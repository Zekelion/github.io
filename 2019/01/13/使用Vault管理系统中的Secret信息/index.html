<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="eriksen">
  <!-- Open Graph Data -->
  <meta property="og:title" content="使用Vault管理系统中的Secret信息 (一)">
  <meta property="og:description" content="">
  <meta property="og:site_name" content="Eriksen&#39;s Homepage">
  <meta property="og:type" content="article">
  <meta property="og:image" content="https://zekelion.github.io">
  
    <link rel="alternate" href="/atom.xml" title="Eriksen&#39;s Homepage" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/icon.jpg">
  

  <!-- Site Title -->
  <title>Eriksen's Homepage</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/post.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">使用Vault管理系统中的Secret信息 (一)</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="/categories">
                  
                  Category
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/Zekelion">
                  
                  Github
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By eriksen</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-01-13</span>
            <span class="time">11:11:53</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/Backend/">Backend</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/infrastructure/">#infrastructure</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>本文要讨论的系统中的Secret信息，可以理解为在系统运行所需的配置项中，例如数据库连接用户/密钥、对接API服务所需的appId/appSecret、基本的Basic Auth信息等类似的敏感信息。</p>
<p>一般来说，我们可能会将这些信息明文或加密后固化在系统启动的配置文件中，又或者经由启动环境变量参数传入系统并覆盖到相应的配置项中。前者可能存在的问题可能会有：系统配置与环境的耦合严重，例如修改DB的认证信息后旧有的配置不再适用；安全性问题客观存在，即使是数据加密后存放在配置文件中，本质上也会在代码中暴露出来；固定化的配置方式，天然不支持动态口令的获取，我们只能通过一些定时任务来更新这些动态口令。后者的问题在于：虽然通过参数传入的方式可以减少一部分固化的配置代码，但是本质上这些配置代码只是转移到了系统启动的运维指令中，同时也会给运维行为增加了额外的负担；另外，动态的口令的问题依旧存在，仍然需要自行定时获取</p>
<p>进一步思考，随着系统的增长，整个系统的体系中可能会存在不同技术选型的子系统，这些系统可能会分布在不同的节点上，更极端的情况下，这些节点不会是都存在在一个可信的、封闭的内部环境中。此时我们就很可能需要更高安全级的Secret信息获取的方式，同时需要对Secret信息获取的行为进行审计，甚至在这些信息变更的时候通知到子系统</p>
<p>一种解决的思路是将这些分布在系统各处的零散Secret信息交由一个中心来进行统一管理，各个系统可以通过这个中心来获取自己所需的Secret信息。实现这个Secret信息管理中心可以按照保护等级大致分为三个等级:</p>
<img src="https://cdn-images-1.medium.com/max/800/1*9AAsLm7ATw8Fl8aVbJQdYw.png" title="Refrence [1]">
<ul>
<li>Limited Access<br>Secret信息被存放在一个限制访问的仓库/服务中，例如一个私有的git仓库</li>
<li>Encrypted Secrets<br>Secret信息经过编码后，再存储到存储层</li>
<li>Management<br>提供更高级别、更细粒度的控制的应用，提供诸如获取信息权限管控、审计日志 (audit log)等功能<ul>
<li>ACL<br>   Access Control List 这里即获取权限控制</li>
<li>TTL<br>   Time to Live 对某些Secret信息设定存活时间，实现动态口令/凭据</li>
</ul>
</li>
</ul>
<p>不同级别的安全等级相应的也会提升对应的复杂度，上述的三个级别也可以看做是我们实现Secret信息管理的几个里程碑。实际落地时，我们除了需要考虑当前的系统客观环境因素之外，还应该考虑一个关键的问题–在什么时候可以达到我们可以接受的安全程度，在什么时候停止 (Where does it end)</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="git-repository"><a href="#git-repository" class="headerlink" title="git repository"></a>git repository</h4><p>我们可以简单的只对Secret信息的获取进行限制，使用一个私有的git仓库进行管理。私有的git仓库天然支持用户的信息校验，只有注册到该仓库的用户才有pull相应信息的权限，同时对于不同环境的隔离也可以通过branch来进行分隔，另外我们也可以利用git的版本管理来快速实现配置项的版本回退。相应在客户端，我们需要checkout对应分支的配置文件，进行读取而后使用这些配置</p>
<p>在这种解决方案中，由于配置是在文件级别上进行操作，在运维人员提交配置的时候，可能会引起配置文件的冲突，那么就很可能需要运维人员多次进行冲突的修改；另外，对于客户端的应用也并不方便，需要我们在启动之前拉取代码并加以读取，进行更多的文件读操作，影响启动速度。同时对于客户端的权限有可能不够细致，不能直接做到对某个具体的客户端只授予某个文件或某个文件夹的权限 (当然使用hook机制可以实现这一功能)</p>
<h4 id="Config-Management-Server"><a href="#Config-Management-Server" class="headerlink" title="Config Management Server"></a>Config Management Server</h4><p>我们也可以使用统一的配置中心来对Sercet信息进行集中管理，例如Spring Cloud Config。这样的情况下，配置中心会单独成为一个服务，暴露出相应的配置接口以供各个子系统调用。配置中心会继承自己的Backend来对数据进行存储，例如git、DB、consul… 当然基于这些不同的存储方式，配置中心自然也会继承它们的局限性。另外使用配置中心时，为了保证获取Sercet信息的安全性，需要我们对获取行为、数据存储添加一些保密措施，例如自行对数据进行加密操作，或者是简单集成一个可以提供这样的保护措施的组件来作为配置中心的存储后端</p>
<h4 id="Hashicorp-Vault"><a href="#Hashicorp-Vault" class="headerlink" title="Hashicorp Vault"></a>Hashicorp Vault</h4><p>以下我们重点关注的是 Hashicorp Vault (后文简称为Vault) ，参考我们之前提到的实现Secret Management的三个阶段，Vault可以辅助我们快速构建第三级别的Mangement Server，它提供了完备且强大的功能来帮助我们完成这一目标</p>
<p>如下图，简单来说Vault使用场景中会包含暴露接口的Vault Server服务中心、Secret信息的管理组件、身份验证服务、实际获取Secret信息的客户端</p>
<img src="https://www.datocms-assets.com/2885/1539718548-howvaultworks3.svg" title="Reference [2]">
<hr>
<p><strong>我们可以利用Vault做什么</strong></p>
<ul>
<li>Secure Secret Storage<br>Vault可以对key/value形式的Secret信息进行加密并存储，因而仅仅获取到原始的存储数据并不能获取到真正的信息。持久化的方式包括写到磁盘、Consul…</li>
<li>Dynamic Secrets<br>Vault可以为某些系统生产动态口令，例如Database；在创建动态口令之后，Vault可以自动吊销那些过期的口令</li>
<li>Data Encryption<br>Vault可以在不存储的情况下对数据进行加密/解密操作。在一些需要设计加密算法的场景时，可以使用这样的功能进行辅助操作</li>
<li>Leasing and Renewal<br>Vault中所有的Secret信息都会与Vault订立一个”租约”，实质上是这些信息会有一定的有效期，当有效期截止的时候，Vault会自动吊销相应的信息。相应的，客户端需要通过Vault的内置刷新API来对想要的信息进行刷新操作</li>
<li>Revocation<br>Vault不仅仅可以对单个的Secret信息进行吊销操作，还可以对Secret树进行吊销操作。例如吊销一个用户的所有相关信息</li>
</ul>
<p>对比前两种解决方案，Vault可以比git更方便地提供细粒度的权限管理与数据加密、获取方案；对比配置中心，Vault可以提供更为轻量级的解决方案</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] <a href="https://medium.com/slalom-technology/secret-management-architectures-finding-the-balance-between-security-and-complexity-9e56f2078e54" target="_blank" rel="noopener">Secret Management Architectures: Finding the balance between security and complexity</a></p>
<p>[2] <a href="https://www.hashicorp.com/products/vault/" target="_blank" rel="noopener">Hashicorp Vault</a></p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        </p><p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

